#!/usr/bin/env perl

use strict;
use warnings;
use POSIX qw(strftime);
use List::Util qw(sum product);

no warnings 'experimental::smartmatch';

my $log = "";
my %args = @ARGV;

if (exists $args{'--help'}) {
	print("
Filters logs from stdin, for example:

  tail -f mylog.log | log-filter --block spam,warning,fish

Usage: log-filter [args]
  --block   comma separated list of words, any output in less then 1s containing this word will be filtered out
  --window  window time in seconds to group logs, by default it's 1s
  --help    shows this help

"
	);
	exit();
}

my $window = $args{'--window'} || 1;


sub main {
	local $SIG{ALRM} = sub {
		process_log();
		$log = "";
		main();
	};
	while (my $line = <STDIN>) {
		$log .= $line;
		alarm($window);
	}
	process_log();
}


sub process_log {
	my @lines = split_lines($log);
	my @filtered_words = split ",", ($args{'--block'} || '');

	my $today = strftime "%Y-%m-%d", localtime;

	my $filename = $ENV{"HOME"} . '/.log-filter-history';
	open(my $fh, '>>', $filename) or die "Could not open file '$filename' $!";

	@lines = grep {
		my @words = split_words($_);
		my @matching_words = grep { $_ ~~ @words } @filtered_words;
		my $included = not scalar @matching_words;

		print $fh "$today:", join(",", @words), "\n";

		$included;
	} @lines;
	close $fh;

	my $separator = "--------------------------------------------------------------------------------";
	print join $separator, @lines;
}


sub split_lines {
	my $log = shift;

	return split /----+/, $log;
}


sub split_words {
	my $log = shift;

	return grep { $_ } map { $_ =~ s/[^a-z-_\/]//gir } split /\s|::|\//, $log;
}


sub parse_history {
	my $history = {};
	if (open(my $fh, '<:encoding(UTF-8)', $ENV{"HOME"} . '/.log-filter-history')) {
		while (my $row = <$fh>) {
			chomp $row;
			my ($date, $wordlist) = split ":", $row;
			my @words = split ",", $wordlist;
			$history->{$date}{$_}++ for @words;
		}
	}
	return $history;
}


sub calculate_totals {
	my ($words, $history) = @_;

	my $totals = {};
	for my $date (keys %$history) {
		$totals->{dates}{$date} = sum values %{$history->{$date}};
		$totals->{words}{$_} += $history->{$date}{$_} || 0 for @$words;
	}

	return $totals;
}


sub word_posteriors {
	my ($word, $history, $totals) = @_;

	my $total_words = sum values %{$totals->{dates}};

	my $posteriors = {};
	for my $date (keys %$history) {
		if ($totals->{words}{$word} < 1) {
			$posteriors->{$date} = 0.1;
			next;
		}
		my $P_foo_given_date = $history->{$date}{$word} / $totals->{dates}{$date};
		my $P_date = $totals->{dates}{$date} / $total_words;
		my $P_word = $totals->{words}{$word} / $total_words;

		$posteriors->{$date} = ($P_foo_given_date * $P_date) / $P_word;
	}

	return $posteriors;
}


sub posteriors {
	my ($words, $history) = @_;

	my $totals = calculate_totals($words, $history);

	my $posteriors = {};
	for my $word (@$words) {
		my $word_posterior = word_posteriors($word, $history, $totals);
		$posteriors->{$_}{$word} = $word_posterior->{$_} for keys %{$word_posterior};
	}

	return $posteriors;
}

# References:
# This is implementented according to the formula on http://www.paulgraham.com/spam.html
# Although it might not be the most correct Bayes way, we accept his assumptions,
# the difference is explained on https://cs.wellesley.edu/~anderson/writing/naive-bayes.pdf
sub combined_probability {
	my ($posteriors, $n) = @_;

	my $combined_probabilities = {};
	for my $date (keys %{$posteriors}) {
		my $posteriors_for_date = $posteriors->{$date};

		my @relevant_probs = sort {abs($b - 0.5) <=> abs($a - 0.5)} values %{$posteriors_for_date};
		@relevant_probs = @relevant_probs[0..$n - 1];

		my $combined_probability = (product @relevant_probs) / ((product @relevant_probs) + (product map { 1 - $_ } @relevant_probs));
		$combined_probabilities->{$date} = $combined_probability;
	}
	return $combined_probabilities;
}

main() unless caller;